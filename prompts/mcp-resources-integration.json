{
  "id": "mcp-resources-integration",
  "name": "MCP Resources Integration Guide",
  "description": "A comprehensive guide to working with and integrating resources across multiple MCP servers",
  "content": "# MCP Resources Integration Guide\\n\\nYou are an expert on the Model Context Protocol (MCP) ecosystem, specializing in resource integration across multiple MCP servers. Your task is to assist with {{integration_task}} by explaining how to leverage the resources/list method and integrate multiple data sources.\\n\\n## Understanding MCP Resources\\n\\nResources in the MCP ecosystem are named data objects that can be referenced and accessed across different MCP servers. They enable:\\n\\n1. **Cross-server data access**: Retrieving and using data from multiple specialized servers\\n2. **Contextual enrichment**: Adding relevant information to prompt templates\\n3. **Dynamic content generation**: Creating outputs based on up-to-date information\\n4. **Workflow orchestration**: Coordinating complex operations involving multiple data sources\\n\\n## The `resources/list` Method\\n\\nThe `resources/list` method is a powerful capability that enables discovery and exploration of available contextual data sources. It can be used to:\\n\\n- **Discover available resources**: List all accessible data sources across connected MCP servers\\n- **Filter resources by type**: Find specific kinds of resources (files, database records, API results)\\n- **Explore metadata**: View descriptions, timestamps, and other metadata about available resources\\n- **Support dynamic workflows**: Enable applications to adapt based on available context\\n\\n### Basic Usage\\n\\n```\\n// Example: Listing all available resources\\n{\\n  \\\\\\\"method\\\\\\\": \\\\\\\"resources/list\\\\\\\",\\n  \\\\\\\"params\\\\\\\": {}\\n}\\n\\n// Example: Filtering resources by prefix\\n{\\n  \\\\\\\"method\\\\\\\": \\\\\\\"resources/list\\\\\\\",\\n  \\\\\\\"params\\\\\\\": {\\n    \\\\\\\"prefix\\\\\\\": \\\\\\\"github://\\\\\\\"\\n  }\\n}\\n```\\n\\n## Integrating Resources from Different MCP Servers\\n\\n### Available Resource Types by Server\\n\\n| Server Type | Resource Prefix | Example URI | Description |\\n|-------------|----------------|-------------|-------------|\\n| GitHub | github:// | github://owner/repo/path/to/file | Repository files and metadata |\\n| Filesystem | file:// | file:///path/to/local/file | Local file system access |\\n| PostgreSQL | postgres:// | postgres://database/table/record | Database records and query results |\\n| Memory | memory:// | memory://session/key | Stored session context |\\n| Web | https:// | https://api.example.com/data | Web content and API responses |\\n| {{custom_server}} | {{custom_prefix}} | {{custom_example}} | {{custom_description}} |\\n\\n### Resource Integration Patterns\\n\\n#### 1. Chain of Resources Pattern\\nConnect multiple resources sequentially, where the output of one resource operation becomes the input for the next:\\n\\n```\\n// Step 1: Retrieve configuration from GitHub\\nconst config = await getResource('github://org/repo/config.json');\\n\\n// Step 2: Use config to query database\\nconst queryResults = await getResource(`postgres://database/table?query=${config.queryParams}`);\\n\\n// Step 3: Process results and store in memory\\nawait setResource('memory://session/processed_data', processData(queryResults));\\n```\\n\\n#### 2. Aggregation Pattern\\nCombine data from multiple resources to create a comprehensive context:\\n\\n```\\n// Collect data from multiple sources\\nconst codebase = await getResource('github://org/repo/src');\\nconst documentation = await getResource('file:///local/docs');\\nconst issueTracking = await getResource('https://issues.example.com/api/project');\\n\\n// Combine into unified context\\nconst projectContext = {\\n  code: codebase,\\n  docs: documentation,\\n  issues: issueTracking\\n};\\n```\\n\\n#### 3. Template Enrichment Pattern\\nUse resources to populate template variables dynamically:\\n\\n```\\n// Retrieve template\\nconst template = await getResource('prompts://templates/analysis');\\n\\n// Gather contextual data\\nconst repoStats = await getResource('github://org/repo/stats');\\nconst performanceData = await getResource('postgres://metrics/performance');\\n\\n// Apply template with resource data\\nconst enrichedPrompt = applyTemplate(template, {\\n  project_metrics: repoStats,\\n  performance_insights: performanceData\\n});\\n```\\n\\n## Implementation Guidelines for {{integration_task}}\\n\\n### Step 1: Resource Discovery\\nFirst, use the resources/list method to discover what data sources are available:\\n\\n```javascript\\n// Example resources/list implementation\\nasync function discoverResources() {\\n  const resources = await callMCP({\\n    method: 'resources/list',\\n    params: {}\\n  });\\n  \\n  console.log('Available resources:', resources);\\n  return resources;\\n}\\n```\\n\\n### Step 2: Resource Access Patterns\\nImplement standardized patterns for accessing different resource types:\\n\\n```javascript\\n// Example resource access function\\nasync function getResource(uri) {\\n  const serverType = getServerTypeFromUri(uri);\\n  \\n  const response = await callMCP({\\n    server: serverType,\\n    method: 'resources/get',\\n    params: { uri }\\n  });\\n  \\n  return response.data;\\n}\\n```\\n\\n### Step 3: Resource Integration\\nCombine resources using the appropriate integration pattern for your use case:\\n\\n{{integration_code}}\\n\\n### Step 4: Error Handling and Fallbacks\\nImplement robust error handling for cases where resources may be unavailable:\\n\\n```javascript\\ntry {\\n  const resource = await getResource('github://org/repo/file.json');\\n  // Process resource\\n} catch (error) {\\n  console.error('Error accessing resource:', error);\\n  // Use fallback resource or strategy\\n  const fallbackResource = await getResource('file:///local/fallback.json');\\n}\\n```\\n\\n## Best Practices for Resource Integration\\n\\n1. **Cache appropriately**: Some resources may be expensive to fetch repeatedly\\n2. **Handle failures gracefully**: Use fallbacks when resources are unavailable\\n3. **Consider resource formats**: Different servers may return different data structures\\n4. **Manage dependencies**: Be mindful of resource dependencies and potential circular references\\n5. **Document resource usage**: Make resource URIs and usage patterns explicit\\n6. **Security awareness**: Consider access control implications when sharing resources\\n{{additional_practices}}\\n\\n## Implementation Examples for Common Scenarios\\n\\n### Example 1: Project Analysis Dashboard\\nCombine code repository statistics, issue tracking, and documentation:\\n\\n```javascript\\nasync function buildProjectDashboard() {\\n  // Discover available resources\\n  const resources = await discoverResources();\\n  \\n  // Check if required resources are available\\n  const hasGitHub = resources.some(r => r.startsWith('github://'));\\n  const hasIssues = resources.some(r => r.startsWith('https://issues.'));\\n  \\n  // Gather data from available sources\\n  const repoData = hasGitHub ? \\n    await getResource('github://org/project/stats') : \\n    { error: 'GitHub data unavailable' };\\n    \\n  const issueData = hasIssues ?\\n    await getResource('https://issues.example.com/api/project/stats') :\\n    { error: 'Issue tracker unavailable' };\\n    \\n  // Combine into unified dashboard data\\n  return {\\n    code_metrics: repoData,\\n    issue_metrics: issueData,\\n    timestamp: new Date().toISOString()\\n  };\\n}\\n```\\n\\n### Example 2: Dynamic Document Generation\\nGenerate documentation by combining templates with real-time data:\\n\\n```javascript\\nasync function generateDocumentation() {\\n  // Get document template\\n  const template = await getResource('prompts://templates/documentation');\\n  \\n  // Gather data from multiple sources\\n  const apiSchema = await getResource('file:///api/schema.json');\\n  const usageStats = await getResource('postgres://analytics/api_usage');\\n  const exampleCode = await getResource('github://org/examples/api');\\n  \\n  // Generate documentation\\n  return applyTemplate(template, {\\n    schema: apiSchema,\\n    usage: usageStats,\\n    examples: exampleCode\\n  });\\n}\\n```\\n\\n### Example 3: {{custom_example_name}}\\n{{custom_example_description}}\\n\\n```javascript\\n{{custom_example_code}}\\n```\\n\\n## Resources/List Method in Action\\n\\nThe resources/list method serves multiple important functions:\\n\\n1. **Discovery and Exploration**: Clients can discover what contextual resources are available\\n2. **Workflow Orchestration**: Automated workflows can determine which resources to use\\n3. **Enhanced UI/UX**: User interfaces can show available resources for selection\\n4. **Integration with External Services**: Bridge between clients and external data sources\\n\\nExample implementation of a resource explorer using resources/list:\\n\\n```javascript\\nasync function exploreResources(prefix = '') {\\n  const resources = await callMCP({\\n    method: 'resources/list',\\n    params: { prefix }\\n  });\\n  \\n  // Group resources by type\\n  const resourcesByType = resources.reduce((groups, uri) => {\\n    const type = uri.split('://')[0];\\n    if (!groups[type]) groups[type] = [];\\n    groups[type].push(uri);\\n    return groups;\\n  }, {});\\n  \\n  // Display available resources by type\\n  for (const [type, uris] of Object.entries(resourcesByType)) {\\n    console.log(`${type} resources (${uris.length}):`);\\n    uris.forEach(uri => console.log(`  - ${uri}`));\\n  }\\n  \\n  return resourcesByType;\\n}\\n```\\n\\n## Conclusion\\n\\nEffective integration of resources across MCP servers is a powerful pattern that enables complex workflows, rich contextual awareness, and dynamic content generation. By understanding the resources/list method and implementing appropriate integration patterns, you can leverage the full potential of the MCP ecosystem for {{integration_task}}.\\n\\nWhat specific aspect of MCP resource integration would you like to explore further?",
  "isTemplate": true,
  "variables": [
    "integration_task",
    "custom_server",
    "custom_prefix",
    "custom_example",
    "custom_description",
    "integration_code",
    "additional_practices",
    "custom_example_name",
    "custom_example_description",
    "custom_example_code"
  ],
  "tags": [
    "mcp",
    "resources",
    "integration",
    "advanced",
    "multi-server",
    "template"
  ],
  "createdAt": "2025-03-15T16:00:00.000Z",
  "updatedAt": "2025-03-15T16:00:00.000Z",
  "version": 1,
  "metadata": {
    "recommended_servers": [
      "github",
      "filesystem",
      "postgres",
      "memory",
      "prompts"
    ],
    "example_variables": {
      "integration_task": "building a comprehensive project analysis tool",
      "custom_server": "TimeSeries",
      "custom_prefix": "timeseries://",
      "custom_example": "timeseries://metrics/cpu-usage/7d",
      "custom_description": "Historical time-series data for metrics and monitoring",
      "integration_code": "async function integrateProjectAnalysis() { ... }",
      "additional_practices": "7. **Version awareness**: Consider resource version compatibility\n8. **Performance tracking**: Monitor resource access patterns and optimize frequent operations\n9. **Scope limitation**: Only access resources directly relevant to the current task\n10. **Progressive enhancement**: Design systems that work with minimal resources but enhance capabilities when more are available",
      "custom_example_name": "Cross-Server Data Validation",
      "custom_example_description": "Validate data consistency across different storage systems by comparing repositories, databases, and local files:",
      "custom_example_code": "async function validateDataConsistency() { ... }"
    }
  },
  "examples": []
}
